#+STARTUP: overview
#+TITLE: Keyhenge's Emacs
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;
* Credit
This repo was adapted/modifed from Uncle Dave's Emacs, found here: =https://github.com/daedreth/UncleDavesEmacs=
The majority of the configuration and especially the functions were written by him, so a huge thank you for making my emacs experience a lot more pleasant.

* TODO Installation
** Quick Installation
:PROPERTIES:
:CUSTOM_ID: quick-install
:END:
=git clone https://github.com/Keyhenge/Emacs.git ~/.emacs.d=

Running the above command will clone this repository into your emacs settings, overwriting anything you have there already. I highly recommend backing up your current settings by copying them into another repository (e.g. =cp ~/.emacs.d ~/.emacs.d.bak=).

This config file is saved as an org file, then parsed into valid emacs-lisp. As such, most sections have some sort of rambling attached explaining what the keybindings are, what packages I've added, why things are the way they are, etc. You should read through them to get the full benefit of the configuration.

** TODO Dependencies for:
*** EXWM
EXWM is a window manager with Emacs as its base. Everything is treated as a buffer, allowing us to use Emacs bindings across the entire system and keep "mode-switching" to a minimum.

At the moment, I'm not using EXWM due to rocky support on NixOS. However, I'm keeping this here for later.
**** From the package manager:
 - =xorg-server=, the windowing system ubiquitous among Linux distros, though slowly being replaced by Wayland. Unfortunately, Emacs doesn't support Wayland as of yet, and there is no EXWM equivalent.
 - =pulsemixer=, a CLI/curses mixer for PulseAudio. Used for audio control functions.
 - =imagemagick=, a simple image suite we'll be using to take screenshots with.
 - =fira-code=, a very nice, readable font. If you want to use something else, make sure to edit the init.el file.

***** Optional
 - A browser (this config uses =firefox=)
 - A composite manager (recommended, I use =compton=)
 - =noto-cjk=, to display foreign languages correctly
 - =slock=, if you want to lock the screen

*** TRAMP
TRAMP (Transparent Remote Access, Multiple Protocols), is used to ssh into other users and machines. We'll primarily use it to make edits as root, but it's also incredibly useful for remote editing.
**** From the package manager:
 - =sudo=, properly configured for your user.

*** TODO EMMS
**** From the package manager:
 - =mpd=, 
 - =mpv=, 

*** TODO Programming
You'll also need various programs for code completion, REPLs, and style guide enforcement.
**** Package manager
 - =clang=, for c/c++ completion.
 - =sbcl=, for clisp completion and its REPL.
 - =virtualenv=, for python completion.
 - =lua=, to run lua code, completion, and REPL.

**** pip (python package manager)
 - =pip install jedi flake8 autopep8=, for code completion and style enforcement.

**** TODO Go
** TODO Some notes
*** On use-package
=use-package= automatically downloads and configures our packages with minimal effort. Our =init.el= automatically checks for whether =use-package= is installed, and downloads/installs it if it is not.
*** On the format of the configuration
As mentioned in the [[Quick Installation]] section, this config file is saved as a .org file, which is a markup language and one of the best packages in emacs. At launch, this file is stripped of all of its text save for sections labeled as emacs-lisp, which is then parsed into config.el and used. You can find some more info on Org-mode [[https://orgmode.org/manual/][here]], and my custom configuration in the [[Org]] section. 
*** TODO On the use case of this configuration
For now, this configuration is simply a nice way to use emacs, with a lot of time saving packages, functions and shortcuts. In the future however, I'll be reinstating the [[EXWM]] section to use emacs as a desktop environment. If you don't want that, it's simple enough to delete that section, as the rest of the configuration does not depend on it.
*** TODO On the keybindings

* TODO Interface
** TODO Window Manager
 Everything surrounding EXWM is contained here, as well as a few extra controls which will only be accesible while emacs is in focus.
*** TODO EXWM
 
**** Installation
 +BEGIN_SRC emacs-lisp
   (use-package exwm
     :ensure t
     :config

       ;; necessary to configure exwm manually
       (require 'exwm-config)

       ;; fringe size, most people prefer 1
       (fringe-mode 3)

       ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly in the exwm instance
       (server-start)

       ;; this fixes issues with ido mode, if you use helm, get rid of it
       (exwm-config-ido)

       ;; a number between 1 and 9, exwm creates workspaces dynamically so I like starting out with 1
       (setq exwm-workspace-number 1)

       ;; this is a way to declare truly global/always working keybindings
       ;; this is a nifty way to go back from char mode to line mode without using the mouse
       (exwm-input-set-key (kbd "s-r") #'exwm-reset)
       (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
       (exwm-input-set-key (kbd "s-w") #'exwm-workspace-swap)

       ;; the next loop will bind s-<number> to switch to the corresponding workspace
       (dotimes (i 10)
         (exwm-input-set-key (kbd (format "s-%d" i))
                             `(lambda ()
                                (interactive)
                                (exwm-workspace-switch-create ,i))))

       ;; the simplest launcher, I keep it in only if dmenu eventually stopped working or something
       (exwm-input-set-key (kbd "s-&")
                           (lambda (command)
                             (interactive (list (read-shell-command "$ ")))
                             (start-process-shell-command command nil command)))

       ;; an easy way to make keybindings work *only* in line mode
       (push ?\C-q exwm-input-prefix-keys)
       (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

       ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
       (exwm-input-set-simulation-keys
        '(
          ;; movement
          ([?\C-b] . left)
          ([?\M-b] . C-left)
          ([?\C-f] . right)
          ([?\M-f] . C-right)
          ([?\C-p] . up)
          ([?\C-n] . down)
          ([?\C-a] . home)
          ([?\C-e] . end)
          ([?\M-v] . prior)
          ([?\C-v] . next)
          ([?\C-d] . delete)
          ([?\C-k] . (S-end delete))
          ;; selection
          ([?\C-B] . Shift-left)
          ([?\M-B] . C-Shift-left)
          ([?\C-F] . Shift-right)
          ([?\M-F] . C-Shift-right)
          ([?\C-P] . Shift-up)
          ([?\C-N] . Shift-down)
          ([?\C-A] . Shift-home)
          ([?\C-E] . Shift-end)
          ([?\M-V] . Shift-prior)
          ([?\C-V] . Shift-next)
          ;; cut/paste
          ([?\C-w] . ?\C-x)
          ([?\M-w] . ?\C-c)
          ([?\C-y] . ?\C-v)
          ;; search
          ([?\C-s] . ?\C-f)))

       ;; this little bit will make sure that XF86 keys work in exwm buffers as well
       (dolist (k '(XF86AudioLowerVolume
                  XF86AudioRaiseVolume
                  XF86PowerOff
                  XF86AudioMute
                  XF86AudioPlay
                  XF86AudioStop
                  XF86AudioPrev
                  XF86AudioNext
                  XF86ScreenSaver
                  XF68Back
                  XF86Forward
                  Scroll_Lock
                  print))
       (cl-pushnew k exwm-input-prefix-keys))

       ;; this just enables exwm, it started automatically once everything is ready
       (exwm-enable))
 +END_SRC
*** TODO Launchers
 
**** dmenu for emacs
 
 #+BEGIN_SRC emacs-lisp
   (use-package dmenu
     :ensure t
     :bind
       ("s-SPC" . 'dmenu))
 #+END_SRC

**** Functions to start processes
 
 #+BEGIN_SRC emacs-lisp
   (defun exwm-async-run (name)
     (interactive)
     (start-process name nil name))

   (defun daedreth/launch-browser ()
     (interactive)
     (exwm-async-run "firefox"))

   (defun daedreth/lock-screen ()
     (interactive)
     (exwm-async-run "slock"))

   (defun daedreth/shutdown ()
     (interactive)
     (start-process "halt" nil "sudo" "halt"))
 #+END_SRC

**** Keybindings to start processes
 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "<s-tab>") 'daedreth/launch-browser)
   (global-set-key (kbd "<XF86ScreenSaver>") 'daedreth/lock-screen)
   (global-set-key (kbd "<XF86PowerOff>") 'daedreth/shutdown)
 #+END_SRC

*** Audio controls
A set of controls/settings to manipulate audio from inside emacs.
**** Volume
 Some functions we'll be using in a second to mute/raise/lower volume. The volume modifier describes how much the volume will be raised or lowered by.
 #+BEGIN_SRC emacs-lisp
 (defconst volumeModifier "2")
   (defun audio/mute ()
     (interactive)
     (start-process "audio-mute" nil "pulsemixer" "--toggle-mute"))

   (defun audio/raise-volume ()
     (interactive)
     (start-process "raise-volume" nil "pulsemixer" "--change-volume" (concat "+" volumeModifier)))

   (defun audio/lower-volume ()
     (interactive)
     (start-process "lower-volume" nil "pulsemixer" "--change-volume" (concat "-" volumeModifier)))
 #+END_SRC

**** Audio Keybindings
 I have a couple dedicated audio keys on my keyboard, which I bind the above functions to here. That being said, these are the only dedicated audio keys I have, so other audio keybinds (like those defined in [[Media]]) are bound to function keys.
 #+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "<XF86AudioMute>") 'audio/mute)
 (global-set-key (kbd "<XF86AudioRaiseVolume>") 'audio/raise-volume)
 (global-set-key (kbd "<XF86AudioLowerVolume>") 'audio/lower-volume)
 #+END_SRC

*** Screenshots
Gives us basic screenshot capabilities.
**** Screenshotting the entire screen
Bound to <Print Screen>.
 #+BEGIN_SRC emacs-lisp
   (defun daedreth/take-screenshot ()
     "Takes a fullscreen screenshot of the current workspace"
     (interactive)
     (when window-system
     (loop for i downfrom 3 to 1 do
           (progn
             (message (concat (number-to-string i) "..."))
             (sit-for 1)))
     (message "Cheese!")
     (sit-for 1)
     (start-process "screenshot" nil "import" "-window" "root"
                (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
     (message "Screenshot taken!")))
   (global-set-key (kbd "<print>") 'daedreth/take-screenshot)
 #+END_SRC

**** Screenshotting a region
Bound to <Scroll Lock>, which I can practically guarantee you don't use.
 #+BEGIN_SRC emacs-lisp
   (defun daedreth/take-screenshot-region ()
     "Takes a screenshot of a region selected by the user."
     (interactive)
     (when window-system
     (call-process "import" nil nil nil ".newScreen.png")
     (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                   (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
     (call-process "rm" nil nil nil ".newScreen.png")))
   (global-set-key (kbd "<Scroll_Lock>") 'daedreth/take-screenshot-region)
 #+END_SRC

*** Default browser
 I use firefox, though I expect that to change when one of the keyboard-focused browsers (qutebrowser, next, etc.) gets
 proper uBlock/uMatrix support. This may also change to icecat later.
 #+BEGIN_SRC emacs-lisp
   (setq browse-url-browser-function 'browse-url-generic
         browse-url-generic-program "firefox")
 #+END_SRC

** Moving around emacs
 Emacs is a great text editor that can be even better if you actually use it properly. That means remembering the keybindings for whatever task you're doing and using them as often as possible. These configs aim to make those even more useful and waste as little of your time as possible.
*** Prerequisites for other packages
 #+BEGIN_SRC emacs-lisp
   (use-package ivy
     :ensure t)
 #+END_SRC

*** Scrolling
This setting should make emacs never re-center the cursor while scrolling down, instead scrolling line-by-line as you would expect.
 #+BEGIN_SRC emacs-lisp
   (setq scroll-conservatively 100)
 #+END_SRC

*** Which-key
No matter what you're doing in emacs, you WILL frequently forget what key does what. Fortunately, emacs is self documenting and allows you to search for specific functions/describe key combinations. Even more fortunately, the =which-key= package will automatically open a small buffer at the bottom of the screen showing all possible completions of a command.
 #+BEGIN_SRC emacs-lisp
   (use-package which-key
     :ensure t
     :config
       (which-key-mode))
 #+END_SRC

*** Windows/Panes
Many people, myself included, have multiple screens, work with more than 2 files at once, etc. that makes the default windowing behavior of buffers annoying and cumbersome. These small enhancements make those annoyances disappear.
**** switch-window
Cycling through all of your buffers with =C-x o= is tiresome. How about we press it once, have all available buffers display a letter, then press that letter to get to that specific buffer? We'll also make the letters they display easily acessible, starting with the homerow keys.
 #+BEGIN_SRC emacs-lisp
 (use-package switch-window
   :ensure t
   :config
     (setq switch-window-input-style 'minibuffer)
     (setq switch-window-increase 4)
     (setq switch-window-threshold 2)
     (setq switch-window-shortcut-style 'qwerty)
     (setq switch-window-qwerty-shortcuts
         '("a" "s" "d" "f" "g" "h" "j" "k" "l" "w" "e" "r" "i" "o" "p"))
   :bind
     ([remap other-window] . switch-window))
 #+END_SRC

**** Following window splits
Whenever you split your window, your focus will now be on the newly created window. After all, if you're making a new buffer, surely you want to do something with it right?
 #+BEGIN_SRC emacs-lisp
   (defun split-and-follow-horizontally ()
     (interactive)
     (split-window-below)
     (balance-windows)
     (other-window 1))
   (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

   (defun split-and-follow-vertically ()
     (interactive)
     (split-window-right)
     (balance-windows)
     (other-window 1))
   (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
 #+END_SRC

*** Swiper
A much better searching package than the default. Shows a preview of instances of the search text, as well as their line numbers.
 #+BEGIN_SRC emacs-lisp
   (use-package swiper
     :ensure t
     :bind ("C-s" . 'swiper))
 #+END_SRC

*** Buffers
Buffers contain just about everything in emacs, so we should make them better.
**** Always murder current buffer
=C-x k= should always kill the buffer that currently has focus.
 #+BEGIN_SRC emacs-lisp
   (defun kill-current-buffer ()
     "Kills the current buffer."
     (interactive)
     (kill-buffer (current-buffer)))
   (global-set-key (kbd "C-x k") 'kill-current-buffer)
 #+END_SRC

**** Turn switch-to-buffer into ibuffer
 #+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "C-x b") 'ibuffer)
 #+END_SRC

**** close-all-buffers
Sets =Ctrl+Mod+Super+k= to kill all buffers. The key combination should ensure that you never accidently do this.
 #+BEGIN_SRC emacs-lisp
   (defun close-all-buffers ()
     "Kill all buffers without regard for their origin."
     (interactive)
     (mapc 'kill-buffer (buffer-list)))
   (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
 #+END_SRC

*** Line Numbers
Many commands in emacs are more useful when you specify how many times you want to do them. Making line numbers relative relieves you of the stress of calculating how many lines you want to affect when doing such a command.
 #+BEGIN_SRC emacs-lisp
   (use-package linum-relative
     :ensure t
     :config
       (setq linum-relative-current-symbol "")
       (add-hook 'prog-mode-hook 'linum-relative-mode))
 #+END_SRC

*** Helm
Helm is another extremely useful package that is used almost everywhere. Efficient fuzzy-finding, directory navigating, command searching, file system editing, it has it all. It's no joke when I say this can almost replace your file manager.
 #+BEGIN_SRC emacs-lisp
   (use-package helm
     :ensure t
     :bind
     ("C-x C-f" . 'helm-find-files)
     ("C-x C-b" . 'helm-buffers-list)
     ("M-x" . 'helm-M-x)
     :config
     (defun daedreth/helm-hide-minibuffer ()
       (when (with-helm-buffer helm-echo-input-in-header-line)
         (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
           (overlay-put ov 'window (selected-window))
           (overlay-put ov 'face
                        (let ((bg-color (face-background 'default nil)))
                          `(:background ,bg-color :foreground ,bg-color)))
           (setq-local cursor-type nil))))
     (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)
     (setq helm-autoresize-max-height 0
           helm-autoresize-min-height 40
           helm-M-x-fuzzy-match t
           helm-buffers-fuzzy-matching t
           helm-recentf-fuzzy-match t
           helm-semantic-fuzzy-match t
           helm-imenu-fuzzy-match t
           helm-split-window-in-side-p nil
           helm-move-to-line-cycle-in-source nil
           helm-ff-search-library-in-sexp t
           helm-scroll-amount 8
           helm-echo-input-in-header-line t)
     :init
     (helm-mode 1))
   (use-package helm-projectile
     :ensure t
     :bind
     ("C-x C-z" . 'helm-projectile)
     :config
     (helm-projectile-on))

   (require 'helm-config)
   (helm-autoresize-mode 1)
   (define-key helm-find-files-map (kbd "C-b") 'helm-find-files-up-one-level)
   (define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
 #+END_SRC

*** avy
Let's say you're writing an essay and you spot a typo a few paragraphs up. You could go up by paragraph, then navigate to the line, and then the word, then the letter OR you could just press =M-s=, type the character you want to jump to, type the 2-3 character string which pops up that differentiates it from the other occurances of the character, and now you're there. 10s of key presses reduced to 3-4.
 #+BEGIN_SRC emacs-lisp
   (use-package avy
     :ensure t
     :bind
       ("M-s" . avy-goto-char))
 #+END_SRC

** Text manipulation
As Emacs is a text editor, we should make some improvements to how you edit text.
*** Mark-Multiple/IEdit
Replace All is an incredibly common use case, so let's have 2 ways of doing it. If you want to specify some number of occurrences to replace after the current one, simply do =C-<number> C-c q=. If you want to edit all occurrences in the file, either place the cursor on a word or highlight a region and then do =C-;=, edit, then press =C-;= again to finish.
 #+BEGIN_SRC emacs-lisp
   (use-package mark-multiple
     :ensure t
     :bind ("C-c q" . 'mark-next-like-this))
   (use-package iedit
     :ensure t)
 #+END_SRC

*** Improved kill-word
I have never understood why "kill-word" doesn't kill the entire word. Therefore, here's a function that does kill the entire word, and replaces the default keybinding.
 #+BEGIN_SRC emacs-lisp
   (defun daedreth/kill-inner-word ()
     "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
     (interactive)
     (forward-char 1)
     (backward-word)
     (kill-word 1))
   (global-set-key (kbd "M-d") 'daedreth/kill-inner-word)
 #+END_SRC

*** Improved copy-word
Copies the word your cursor is currently on.
 #+BEGIN_SRC emacs-lisp
   (defun daedreth/copy-whole-word ()
     (interactive)
     (save-excursion
       (forward-char 1)
       (backward-word)
       (kill-word 1)
       (yank)))
   (global-set-key (kbd "C-c c") 'daedreth/copy-whole-word)
 #+END_SRC

*** Copy a line
Copies the whole line the cursor is on.
 #+BEGIN_SRC emacs-lisp
   (defun daedreth/copy-whole-line ()
     "Copies a line without regard for cursor position."
     (interactive)
     (save-excursion
       (kill-new
        (buffer-substring
         (point-at-bol)
         (point-at-eol)))))
   (global-set-key (kbd "C-c l") 'daedreth/copy-whole-line)
 #+END_SRC

*** Kill a line
Kills the whole like the cursor is on.
 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-c k") 'kill-whole-line)
 #+END_SRC

** Minor conveniences
Just some minor things that help you out once in a while.
*** Visiting the configuration
It's often cumbersome to go looking for this file, so binding it to =C-c e= means you can instantly access it.
 #+BEGIN_SRC emacs-lisp
   (defun config-visit ()
     (interactive)
     (find-file "~/.emacs.d/config.org"))
   (global-set-key (kbd "C-c e") 'config-visit)
 #+END_SRC

*** Reloading the configuration
Rather than typing out =config-reload= into =M-x=, we'll just bind it to =C-c r=
 #+BEGIN_SRC emacs-lisp
   (defun config-reload ()
     "Reloads ~/.emacs.d/config.org at runtime"
     (interactive)
     (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
   (global-set-key (kbd "C-c r") 'config-reload)
 #+END_SRC

*** Subwords
Makes Emacs treat camelCasedWords as separate words.
 #+BEGIN_SRC emacs-lisp
   (global-subword-mode 1)
 #+END_SRC

*** Electric
Whenever you enter one of these characters, the corresponding character is also added. Very convenient for programming.
 #+BEGIN_SRC emacs-lisp
 (setq electric-pair-pairs '(
                            (?\{ . ?\})
                            (?\( . ?\))
                            (?\[ . ?\])
                            (?\" . ?\")
                            ))
 (electric-pair-mode t)
 #+END_SRC

*** Beacon
Changing buffers, windows, moving up/down with =M-v= and =C-v= etc. dramatically alters the cursor's position. This will briefly highlight the line it moved to.
 #+BEGIN_SRC emacs-lisp
   (use-package beacon
     :ensure t
     :config
       (beacon-mode 1))
 #+END_SRC

*** Rainbow
Any time you enter a hexidecimal that resembles a colorcode, it will automatically highlight the code with that color. See [[Some customization]] under Theming (while running this config in your emacs) for an example.
 #+BEGIN_SRC emacs-lisp
   (use-package rainbow-mode
     :ensure t
     :init
       (add-hook 'prog-mode-hook 'rainbow-mode))
 #+END_SRC

*** Show parens
Highlights matching parens and brackets according to their depth.
 #+BEGIN_SRC emacs-lisp
   (show-paren-mode 1)
 #+END_SRC

*** Rainbow delimiters
Color parens and brackets according to their depth. Especially useful in lisp.
 #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters
     :ensure t
     :init
       (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
 #+END_SRC

*** Expand region
Expands the region you're highlighting to the next logical step.
 #+BEGIN_SRC emacs-lisp
   (use-package expand-region
     :ensure t
     :bind ("C-q" . er/expand-region))
 #+END_SRC

*** Hungry deletion
Gets rid of all whitespace until the next non-whitespace character is encountered. This may not be to your taste, in which case I recommend you bind it to some combination of a modifying key and backspace.
 #+BEGIN_SRC emacs-lisp
   (use-package hungry-delete
     :ensure t
     :config
       (global-hungry-delete-mode))
 #+END_SRC

*** Zapping to char
Deletes everything up to a character you choose. Similar to avy's ace-jump, except it deletes everything inbetween you and the character while doing it.
 #+BEGIN_SRC emacs-lisp
   (use-package zzz-to-char
     :ensure t
     :bind ("M-z" . zzz-up-to-char))
 #+END_SRC

** TODO Remote editing

*** Editing with sudo

 #+BEGIN_SRC emacs-lisp
   (use-package sudo-edit
     :ensure t
     :bind
       ("s-e" . sudo-edit))
 #+END_SRC

** Kill ring
The kill ring is your clipboard in Emacs. Whenever you kill or copy a word, it's added to the kill ring, which can be accessed with =M-y=.
*** Maximum entries on the ring
Doubles the size of the default kill ring.
 #+BEGIN_SRC emacs-lisp
   (setq kill-ring-max 120)
 #+END_SRC

*** popup-kill-ring
Default emacs behavior is to cycle through the kill ring with =M-y=. This changes it so that =M-y= brings up a popup, where you can preview and select what you want to paste.
 #+BEGIN_SRC emacs-lisp
   (use-package popup-kill-ring
     :ensure t
     :bind ("M-y" . popup-kill-ring))
 #+END_SRC

** Eshell
Part of the reason to move to emacs over other text editors is all of the great replacements for standard
terminal programs. Sometimes you still need access to a shell for various commands though, and eshell is
a great replacement for bash/zsh/fish that integrates directly with helm.
*** Completion
Command completion isn't that great in eshell, so let's leech from the great completion fish provides.
#+BEGIN_SRC emacs-lisp
  (use-package fish-completion
    :ensure t)
  (when (and (executable-find "fish")
             (require 'fish-completion nil t))
    (global-fish-completion-mode))
  (add-hook 'eshell-mode-hook
            (lambda ()
              (eshell-cmpl-initialize)
              (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
              (define-key eshell-mode-map (kbd "M-p") 'helm-eshell-history)))
#+END_SRC

*** Easy to remember keybinding
 Keeping consistent with my old WM, Super + Enter opens up a shell.
 #+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "<s-return>") 'eshell)
 #+END_SRC

** Regular shell
*** Default shell should be fish
For the rare times I need to use a terminal in emacs that isn't eshell, it should at least be using fish.
 #+BEGIN_SRC emacs-lisp
   (defvar my-term-shell "/usr/local/bin/fish")
   (defadvice ansi-term (before force-fish)
     (interactive (list my-term-shell)))
   (ad-activate 'ansi-term)
 #+END_SRC

** TODO File manager
Maybe dired+?
* TODO Theming
** TODO Basic Interface Settings
Some improvements to the look and feel of Emacs that doesn't use any outside packages.
*** TODO Looks
**** Remove startup screen
By default, Emacs has its own startup screen. We'll be replacing it in [[Dashboard]].
 #+BEGIN_SRC emacs-lisp
 (setq inhibit-startup-message t)
 #+END_SRC

**** Disable menus and scrollbars
Gets rid of the GUI buttons and scrollbars of Emacs. You'll be using your keyboard anyway, so all these do is take up valuable screen space.
 #+BEGIN_SRC emacs-lisp
 (tool-bar-mode -1)
 (menu-bar-mode -1)
 (scroll-bar-mode -1)
 #+END_SRC

**** TODO Disable bell

 #+BEGIN_SRC emacs-lisp
 (setq ring-bell-function 'ignore)
 #+END_SRC

**** Set UTF-8 encoding
Sets all text to UTF-8.
 #+BEGIN_SRC emacs-lisp
   (setq locale-coding-system 'utf-8)
   (set-terminal-coding-system 'utf-8)
   (set-keyboard-coding-system 'utf-8)
   (set-selection-coding-system 'utf-8)
   (prefer-coding-system 'utf-8)
 #+END_SRC

**** Highlight current line
 #+BEGIN_SRC emacs-lisp
   (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
 #+END_SRC

**** Pretty symbols
Changes various symbol names (e.g. =lambda=) to their actual symbol.
 #+BEGIN_SRC emacs-lisp
   (when window-system
         (use-package pretty-mode
         :ensure t
         :config
         (global-pretty-mode t)))
 #+END_SRC

*** Functionality
**** Backups and auto-saves
Rather than polluting your directy with obnoxious =#file.etx#= files, this saves your backups to a designated folder.
 #+BEGIN_SRC emacs-lisp
 (setq make-backup-files t)
 (setq auto-save-default t)
 (setq backup-directory-alist
          `(("." . ,(concat user-emacs-directory "backups"))))
 #+END_SRC

**** Change yes-or-no questions into y-or-n questions
Whenever Emacs asks a yes or no question, you have to type `yes` or `no`, or Emacs refuses to do anything. This shortens that process.
 #+BEGIN_SRC emacs-lisp
 (defalias 'yes-or-no-p 'y-or-n-p)
 #+END_SRC

**** Async
Uses asynchronous processes when possible.
 #+BEGIN_SRC emacs-lisp
   (use-package async
     :ensure t
     :init (dired-async-mode 1))
 #+END_SRC

** Dashboard
Replaces the standard Emacs splash screen with a more streamlined one relevant to whatever you're working on. Change it at your leisure, documentation details can be found [[https://github.com/emacs-dashboard/emacs-dashboard][here]].
 #+BEGIN_SRC emacs-lisp
   (use-package dashboard
     :ensure t
     :config
       (dashboard-setup-startup-hook)
       (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
       (setq dashboard-items '((recents  . 5)
                               (projects . 5)))
       (setq dashboard-banner-logo-title ""))  (use-package dashboard
    :ensure t
    :config
      (dashboard-setup-startup-hook)
      (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
      (setq dashboard-banner-logo-title "今日も一日頑張ってくれ！")

      (setq dashboard-set-navigator t)
      (setq dashboard-set-footer nil)
      (setq dashboard-set-heading-icons t)
      (setq dashboard-set-file-icons t)

      (setq dashboard-items '((recents  . 10)
                              (projects . 10)
                              (bookmarks . 10))))
 #+END_SRC

** Theme
Every good config needs a good theme. I've customized mine to be as easily readible as possible.
*** A nice theme
 #+BEGIN_SRC emacs-lisp
   (use-package zerodark-theme
     :ensure t
     :init
       (load-theme 'zerodark t))
 #+END_SRC

*** Some customization

 #+BEGIN_SRC emacs-lisp
  (let ((class '((class color) (min-colors 89)))
        (default (if (true-color-p) "#abb2bf" "#afafaf"))
        (light (if (true-color-p) "#ccd4e3" "#d7d7d7"))
        (background (if (true-color-p) "#22252c" "#333333"))
        (background-dark (if (true-color-p) "#24282f" "#222222"))
        (background-darker (if (true-color-p) "#22252c" "#222222"))
        (mode-line-inactive (if "#1c2129" "#222222"))
        (mode-line-active (if (true-color-p) "#6f337e" "#875f87"))
        (background-lighter (if (true-color-p) "#3a3f4b" "#5f5f5f"))
        (background-red (if (true-color-p) "#4c3840" "#5f5f5f"))
        (bright-background-red (if (true-color-p) "#744a5b" "#744a5b"))
        (background-purple (if (true-color-p) "#48384c" "#5f5f5f"))
        (background-blue (if (true-color-p) "#38394c" "#444444"))
        (bright-background-blue (if (true-color-p) "#4e5079" "#4e5079"))
        (background-green (if (true-color-p) "#3d4a41" "#5f5f5f"))
        (bright-background-green (if (true-color-p) "#3f6d54" "#3f6d54"))
        (background-orange (if (true-color-p) "#4a473d" "#5f5f5f"))
        (hl-line (if (true-color-p) "#2c323b" "#333333"))
        (grey (if (true-color-p) "#cccccc" "#cccccc"))
        (grey-dark (if (true-color-p) "#666666" "#666666"))
        (highlight (if (true-color-p) "#3e4451" "#5f5f5f"))
        (comment (if (true-color-p) "#687080" "#707070"))
        (orange (if (true-color-p) "#da8548" "#d7875f"))
        (orange-light (if (true-color-p) "#ddbd78" "#d7af87"))
        (red (if (true-color-p) "#ff2727" "#ff3a3f"))
        (red-light (if (true-color-p) "#ff6464" "#ff8070"))
        (purple (if (true-color-p) "#c678dd" "#d787d7"))
        (purple-dark (if (true-color-p) "#64446d" "#5f5f5f"))
        (blue (if (true-color-p) "#61afef" "#5fafff"))
        (blue-dark (if (true-color-p) "#1f5582" "#005f87"))
        (green (if (true-color-p) "#98be65" "#87af5f"))
        (green-light (if (true-color-p) "#9eac8c" "#afaf87"))
        (peach "PeachPuff3")
        (diff-added-background (if (true-color-p) "#284437" "#284437"))
        (diff-added-refined-background (if (true-color-p) "#1e8967" "#1e8967"))
        (diff-removed-background (if (true-color-p) "#583333" "#580000"))
        (diff-removed-refined-background (if (true-color-p) "#b33c49" "#b33c49"))
        (diff-current-background (if (true-color-p) "#29457b" "#29457b"))
        (diff-current-refined-background (if (true-color-p) "#4174ae" "#4174ae")))

    (custom-theme-set-faces
     'zerodark
     `(default ((,class (:background ,background-darker :foreground ,default))))

     ;; Font lock faces
     `(font-lock-builtin-face ((,class (:foreground ,blue :weight bold))))
     `(font-lock-comment-face ((,class (:foreground ,comment :slant italic))))
     `(font-lock-constant-face ((,class (:foreground ,orange :weight bold))))
     `(font-lock-function-name-face ((,class (:foreground ,blue))))
     `(font-lock-keyword-face ((,class (:foreground ,red-light :weight bold))))
     `(font-lock-string-face ((,class (:foreground ,green))))
     `(font-lock-doc-face ((,class (:foreground ,green-light))))
     `(font-lock-type-face ((,class (:foreground ,blue))))
     `(font-lock-variable-name-face ((,class (:foreground ,blue))))
     `(font-lock-warning-face ((,class (:foreground ,red :weight bold :background ,background-red))))

     `(fancy-battery-charging ((,class (:background ,background-green :height 1.0 :bold t))))
     `(fancy-battery-discharging ((,class (:background ,background-green :height 1.0))))
     `(fancy-battery-critical ((,class (:background ,background-green :height 1.0))))

     ;; mode line stuff
     `(mode-line ((,class (:background ,background-green :height 1.0 :foreground ,green
                                       :distant-foreground ,background-green
                                       :box ,(when zerodark-use-paddings-in-mode-line
                                               (list :line-width 1 :color background-green))))))

     `(mode-line-inactive ((,class (:background ,background-green :height 1.0 :foreground ,default
                                                :distant-foreground ,background-green
                                                :box ,(when zerodark-use-paddings-in-mode-line
                                                        (list :line-width 1 :color background-green))))))

     `(header-line ((,class (:inherit mode-line-inactive))))

     `(powerline-active0 ((,class (:height 0.8 :foreground ,green :background ,background-green
                                           :distant-foreground ,background-green))))
     `(powerline-active1 ((,class (:height 0.8 :foreground ,green :background ,green-light
                                           :distant-foreground ,background-green))))
     `(powerline-active2 ((,class (:height 0.8 :foreground ,green :background ,background-green
                                           :distant-foreground ,background-green))))
     `(powerline-inactive0 ((,class (:height 0.8 :foreground ,green :background ,background-green
                                             :distant-foreground ,background-green))))
     `(powerline-inactive1 ((,class (:height 0.8 :foreground ,green :background ,green-light
                                             distant-foreground ,background-green))))
     `(powerline-inactive2 ((,class (:height 0.8 :foreground ,green :background ,background-green
                                             :distant-foreground ,background-green))))

     `(dashboard-heading-face ((,class (:background ,background-dark :foreground ,green
                                                    :bold t :height 0.9))))
     `(dashboard-banner-logo-title-face ((,class (:background ,background-dark :foreground ,green
                                                              :bold t :height 0.9))))
     `(widget-button ((,class (:background ,background-dark :foreground ,default :bold nil
                                           :underline t :height 0.9))))

     ;; erc stuff
     `(erc-nick-default-face ((,class :foreground ,green :background ,background-dark :weight bold)))

     ;; org stuff
     `(outline-1 ((,class (:foreground ,blue :weight bold :height 1.8 :bold nil))))
     `(outline-2 ((,class (:foreground ,red-light :weight bold :height 1.7 :bold nil))))
     `(outline-3 ((,class (:foreground ,peach :weight bold :height 1.6 :bold nil))))
     `(outline-4 ((,class (:foreground ,green-light :weight bold :height 1.5 :bold nil))))
     `(outline-5 ((,class (:foreground ,purple :weight bold :height 1.4 :bold nil))))
     `(outline-6 ((,class (:foreground ,orange :weight bold :height 1.3 :bold nil))))
     `(outline-7 ((,class (:foreground ,grey :weight bold :height 1.2 :bold nil))))
     `(outline-8 ((,class (:foreground ,blue-dark :weight bold :height 1.1 :bold nil))))
     `(org-block-begin-line ((,class (:background ,background-green :foreground ,green
                                                  :bold t :height 1.0))))
     `(org-block-end-line ((,class (:background ,background-green :foreground ,green
                                                :bold t :height 1.0))))))
 #+END_SRC

** TODO Modeline
The modeline is at the bottom of every single buffer in Emacs and contains all of the information you would need. If we're going to use EXWM, it also needs to contain system information and anything that would appear on a standard status bar.
*** Spaceline
A modified powerline used in spacemacs. Easy configuration and looks good with the theme.
 #+BEGIN_SRC emacs-lisp
   (use-package spaceline
     :ensure t
     :config
     (require 'spaceline-config)
       (setq spaceline-buffer-encoding-abbrev-p nil)
       (setq spaceline-line-column-p nil)
       (setq spaceline-line-p nil)
       (setq powerline-default-separator (quote arrow))
       (spaceline-spacemacs-theme))
 #+END_SRC

*** TODO Cursor position
Does this do anything right now?
 #+BEGIN_SRC emacs-lisp
   (setq line-number-mode t)
   (setq column-number-mode t)
 #+END_SRC

*** Clock
Shows a clock and the date to the bottom right. 
**** Time format
If you don't want a 24-hour clock, set the first line to `nil`.
 #+BEGIN_SRC emacs-lisp
   (setq display-time-24hr-format t)
   (setq display-time-format "%H:%M - %d %B %Y")
 #+END_SRC

**** Enabling the mode
 #+BEGIN_SRC emacs-lisp
   (display-time-mode 1)
 #+END_SRC

*** TODO Battery indicator

 +BEGIN_SRC emacs-lisp
   (use-package fancy-battery
     :ensure t
     :config
       (setq fancy-battery-show-percentage t)
       (setq battery-update-interval 15)
       (if window-system
         (fancy-battery-mode)
         (display-battery-mode)))
 #+END_SRC

*** TODO System monitor
Activates a small system monitor in the minibuffer showing CPU usage, memory, networking, etc.
This is currently marked as TODO since sometimes it won't turn off.
 #+BEGIN_SRC emacs-lisp
   (use-package symon
     :ensure t
     :bind
     ("s-h" . symon-mode))
 #+END_SRC

*** Diminishing modes
Hides the following modes from your modeline in order to save room.
 #+BEGIN_SRC emacs-lisp
   (use-package diminish
     :ensure t
     :init
     (diminish 'which-key-mode)
     (diminish 'linum-relative-mode)
     (diminish 'hungry-delete-mode)
     (diminish 'visual-line-mode)
     (diminish 'subword-mode)
     (diminish 'beacon-mode)
     (diminish 'irony-mode)
     (diminish 'page-break-lines-mode)
     (diminish 'auto-revert-mode)
     (diminish 'rainbow-delimiters-mode)
     (diminish 'rainbow-mode)
     (diminish 'yas-minor-mode)
     (diminish 'flycheck-mode)
     (diminish 'helm-mode))
 #+END_SRC

* Programming

** Projectile

*** Enable projectile globally

 #+BEGIN_SRC emacs-lisp
   (use-package projectile
     :ensure t
     :init
       (projectile-mode 1)
     :bind
       ("C-c p" . 'projectile-command-map))
 #+END_SRC

*** Let projectile call make

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "<f5>") 'projectile-compile-project)
 #+END_SRC

** Yasnippet

#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :config
        (use-package yasnippet-snippets
          :ensure t)
        (yas-reload-all))
#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC

** Company mode

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 1)
    (setq company-minimum-prefix-length 3))

  (with-eval-after-load 'company
    ;;(define-key company-active-map (kbd "M-n") nil)
    ;;(define-key company-active-map (kbd "M-p") nil)
    ;;(define-key company-active-map (kbd "C-n") #'company-select-next)
    ;;(define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC

** Git integration

*** magit
 #+BEGIN_SRC emacs-lisp
   (use-package magit
     :ensure t
     :config
     (setq magit-push-always-verify nil)
     (setq git-commit-summary-max-length 50)
     :bind
     ("M-g" . magit-status))
 #+END_SRC

** Language Server Protocol

#+BEGIN_SRC emacs-lisp
; Install relevant packages
(use-package lsp-mode)
(use-package company-lsp)
(use-package lsp-ui)

; Define Hydra keybinds
(defhydra hydra-lsp (:exit t :hint nil)
  "
 Buffer^^               Server^^                   Symbol
-------------------------------------------------------------------------------------
 [_f_] format           [_M-r_] restart            [_d_] declaration  [_i_] implementation  [_o_] documentation
 [_m_] imenu            [_S_]   shutdown           [_D_] definition   [_t_] type            [_r_] rename
 [_x_] execute action   [_M-s_] describe session   [_R_] references   [_s_] signature"
  ("d" lsp-find-declaration)
  ("D" lsp-ui-peek-find-definitions)
  ("R" lsp-ui-peek-find-references)
  ("i" lsp-ui-peek-find-implementation)
  ("t" lsp-find-type-definition)
  ("s" lsp-signature-help)
  ("o" lsp-describe-thing-at-point)
  ("r" lsp-rename)

  ("f" lsp-format-buffer)
  ("m" lsp-ui-imenu)
  ("x" lsp-execute-code-action)

  ("M-s" lsp-describe-session)
  ("M-r" lsp-restart-workspace)
  ("S" lsp-shutdown-workspace))
#+END_SRC

** Specific languages

*** c/c++

#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)

  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))

  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** python

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)

  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC

*** emacs-lisp

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC

*** bash

#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC

*** lua/löve

I must regrettably admit that =company= sucks with Lua/LÖVE.
Which is also why I have =AC= now.
I needed to do some shenanigans to get great auto-completion but here goes.
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'yas-minor-mode)
  (add-hook 'lua-mode-hook 'flycheck-mode)

  ;;; this will download the necessary modules from git
  (let (value)
    (dolist (element '("love" "lua") value)
      (unless (file-directory-p (concatenate 'string (getenv "HOME") "/.emacs.d/auto-complete-" element))
        (shell-command (format "git clone %s %s" (concatenate 'string
                                                              "https://github.com/rolpereira/auto-complete-" element ".el")
                               (concatenate 'string (getenv "HOME") "/.emacs.d/auto-complete-" element) nil)))
      (add-to-list 'load-path (expand-file-name (concatenate 'string "~/.emacs.d/auto-complete-" element)))))

  (require 'auto-complete-love)
  (require 'auto-complete-lua)

  ;;; repl!
  (add-hook 'lua-mode-hook '(lambda ()
                              (local-set-key (kbd "C-c C-s") 'lua-show-process-buffer)
                              (local-set-key (kbd "C-c C-h") 'lua-hide-process-buffer)))

  ;;; ac > company
  (use-package auto-complete
    :ensure t
    :config
    (setq ac-use-menu-map t)
    (setq ac-ignore-case nil)
    (define-key ac-menu-map "\C-n" 'ac-next)
    (define-key ac-menu-map "\C-p" 'ac-previous))

  ;;; this will be changed, it's good enough for now
  (add-hook 'lua-mode-hook '(lambda ()
                              (setq ac-sources '(ac-source-love
                                                 ac-source-lua
                                                 ac-source-abbrev
                                                 ac-source-words-in-same-mode-buffers))
                              (auto-complete-mode)))

  (add-hook 'lua-mode-hook 'auto-complete-mode)

  ;;; I don't even know all the functionality
  (use-package love-minor-mode
    :ensure t
    :config
    (add-hook 'lua-mode-hook 'love-minor-mode))

  ;;; behold, perfection :°
  (global-set-key (kbd "<f9>") '(lambda () (interactive) (start-process "love-play-game" nil "love" default-directory)))
#+END_SRC

*** golang

#+BEGIN_SRC emacs-lisp
  ;; Set environment variables. Needed for the major mode/LSP to see go commands
  (setenv "PATH"
          (concat
           "/usr/local/bin" ":"
           "usr/local/go/bin" ":"
           (getenv "PATH")
           ":" (getenv "HOME") "/go/bin"))
  (setenv "GOPATH" (concat (getenv "HOME") "/go"))
  (setenv "GO111MODULE" "on")

  (use-package go-mode)

  (setq gofmt-command "goimports")
  (defun cce/go-mode-hook ()
    (lsp)
    (company-mode)
    (flycheck-mode)
    (aggressive-indent-mode -1)
    (eldoc-mode))

  (use-package flycheck-golangci-lint
    :ensure t
    :hook (go-mode . flycheck-golangci-lint-setup))

  (add-hook 'go-mode-hook #'cce/go-mode-hook)
  (eval-after-load "go-mode"
    (lambda ()
      (define-key go-mode-map (kbd "C-<tab>") 'company-lsp)))
#+END_SRC

* Misc
** Org

*** Common settings

 #+BEGIN_SRC emacs-lisp
   (setq org-ellipsis " ")
   (setq org-src-fontify-natively t)
   (setq org-src-tab-acts-natively t)
   (setq org-confirm-babel-evaluate nil)
   (setq org-export-with-smart-quotes t)
   (setq org-src-window-setup 'current-window)
   (add-hook 'org-mode-hook 'org-indent-mode)
 #+END_SRC

*** Syntax highlighting for documents exported to HTML

 #+BEGIN_SRC emacs-lisp
   (use-package htmlize
     :ensure t)
 #+END_SRC

*** Line wrapping

 #+BEGIN_SRC emacs-lisp
   (add-hook 'org-mode-hook
	     '(lambda ()
	        (visual-line-mode 1)))
 #+END_SRC

*** Keybindings

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-c '") 'org-edit-src-code)
 #+END_SRC

*** Org Bullets

 #+BEGIN_SRC emacs-lisp
   (use-package org-bullets
     :ensure t
     :config
       (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
 #+END_SRC

*** Easy-to-add emacs-lisp template

 #+BEGIN_SRC emacs-lisp
   (add-to-list 'org-structure-template-alist
	        '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
 #+END_SRC

*** Exporting options

**** latex

 #+BEGIN_SRC emacs-lisp
   (when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
     (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
     (require 'xdvi-search))
 #+END_SRC
**** Twitter Bootstrap

 #+BEGIN_SRC emacs-lisp
   (use-package ox-twbs
     :ensure t)
 #+END_SRC

*** Agenda

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda-list)
  (setq org-agenda-start-day "-3d")
  (setq org-agenda-span 10)
#+END_SRC

** Instant messaging

*** erc, also known as "a way to ask for help on #emacs"

**** Some common settings

 #+BEGIN_SRC emacs-lisp
   (setq erc-nick "keyhenge")
   (setq erc-prompt (lambda () (concat "[" (buffer-name) "]")))
   (setq erc-hide-list '("JOIN" "PART" "QUIT"))
 #+END_SRC

**** Poor mans selectable server list

 #+BEGIN_SRC emacs-lisp
   (setq erc-server-history-list '("irc.freenode.net"
                                   "localhost"))
 #+END_SRC

**** Nick highlighting

 #+BEGIN_SRC emacs-lisp
 (use-package erc-hl-nicks
   :ensure t
   :config
     (erc-update-modules))
 #+END_SRC

*** rich presence for discord

 #+BEGIN_SRC emacs-lisp
   (use-package elcord
     :ensure t)
 #+END_SRC

** Elfeed

#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t)
  (global-set-key (kbd "C-c f") 'elfeed)
#+END_SRC

** Media
EMMS hasn't been working out for me so I've taken to using Mingus/beets instead. Generally it works out fine, 
though I'm still on the lookout for something with a better browser and a tag editor, similar to ncmpcpp
so that I can completely replace it.

*** Mingus with mpd

**** Basic setup for mpd

 #+BEGIN_SRC emacs-lisp
   (use-package mingus
     :ensure t
     :bind
     ("M-p p" . mingus)
     ("C-<f5>" . mingus-prev)
     ("C-<f8>" . mingus-next)
     ("C-<f7>" . mingus-pause)
     ("C-<f6>" . mingus-stop))
 #+END_SRC

**** MPC Setup
***** Setting the default port

 #+BEGIN_SRC emacs-lisp
   (setq mpc-host "localhost:6601")
 #+END_SRC

**** Some more fun stuff
***** Starting the daemon from within emacs

 #+BEGIN_SRC emacs-lisp
   (defun mpd/start-music-daemon ()
     "Start MPD, connects to it and syncs the metadata cache."
     (interactive)
     (shell-command "mpd")
     (mpd/update-database)
     (emms-player-mpd-connect)
     (emms-cache-set-from-mpd-all)
     (message "MPD Started!"))
   (global-set-key (kbd "M-p c") 'mpd/start-music-daemon)
 #+END_SRC

***** Killing the daemon from within emacs

 #+BEGIN_SRC emacs-lisp
   (defun mpd/kill-music-daemon ()
     "Stops playback and kill the music daemon."
     (interactive)
     (emms-stop)
     (call-process "killall" nil nil nil "mpd")
     (message "MPD Killed!"))
   (global-set-key (kbd "M-p k") 'mpd/kill-music-daemon)
 #+END_SRC

***** Updating the database easily
 #+BEGIN_SRC emacs-lisp
   (defun mpd/update-database ()
     "Updates the MPD database synchronously."
     (interactive)
     (call-process "mpc" nil nil nil "update")
     (message "MPD Database Updated!"))
   (global-set-key (kbd "M-p u") 'mpd/update-database)
 #+END_SRC

